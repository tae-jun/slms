/// <reference path="../../../typings/angularjs/angular.d.ts" />
/// <reference path="../../config.ts" />

/*
 * 시작과 동시에 많은 컴포넌트들이 동시에 fetch를 시도한다.
 * 이는 통신 낭비이다.
 * 통신은 한번만 이루어져도 되기 때문이다.
 * 따라서, fetch가 완료된 후 500ms안에 다시 fetch를 시도하면 기존의 데이터를 반환한다.
 * 
 * 하지만 어느 컴포넌트가 가장 먼저 통신이 완료될지 알 수가 없다.
 * 따라서, 가장 먼저 통신을 시도한 컴포넌트에 의해 isFetching이란 불리언 값이 참이 되고
 * isFetching이 true이면 콜백함수를 배열에 추가한다.
 * 그 이후 fetch가 완료되면 콜백함수 배열에 있는 모든 함수들을 실행하고 isFetching은 true가 된다.
 */

module global {
    import config = configuration.global;

    export function lightService($http: ng.IHttpService): LightService {
        var lights: Light[] = [];
        var idLights = {};

        var lastUpdate: Date = new Date(2000);
        var lastUpdateDuration: number = 500;
        var isFetching: boolean = false;
        var callbacks: Function[] = new Array();

        var rtnFuncs: LightService = {
            get: () => {
                return lights;
            },
            fetch: (callback) => {
                if (new Date().getTime() - lastUpdate.getTime() < lastUpdateDuration) {
                    if (callback)
                        callback(lights);

                    return lights;
                }
                else {
                    if (callback) {
                        callbacks.push(callback);
                    }

                    if (!isFetching) {
                        isFetching = true;

                        $http.get(config.lightsUrl)
                            .success((data: any[]) => {
                                lights.splice(0, lights.length);

                                data.forEach((light) => {
                                    var tmp = new Light($http, light);
                                    lights.push(tmp);
                                    idLights[tmp._id] = tmp;
                                });

                                while (callbacks.length) {
                                    callbacks.pop()(lights);
                                }

                                lastUpdate = new Date();
                                isFetching = false;

                                console.log('lights fetched at ' + lastUpdate);
                            })
                            .error((err) => {
                                console.warn('GET -> ' + config.lightsUrl + ' ERROR');
                                console.warn(err);
                                isFetching = false;
                            });

                        return lights;
                    }
                }
            },
            find: (_id) => {
                return idLights[_id];
            },
            create: (data, callback?) => {
                $http.post(config.lightsUrl, data)
                    .success((res) => {


                        if (callback)
                            callback(res);
                    })
                    .error((err) => {
                        console.warn('POST -> ' + config.lightsUrl + ' ERROR');
                        console.warn(err);
                    });
            },
            control: (_id, rgb, callback) => {
                var data = {
                    _id: _id,
                    rgb: rgb
                };
                
                $http.post(config.lightCtrlUrl, data)
                    .success((res) => {
                        if (callback)
                            callback(res);
                    });
            }
        };

        return rtnFuncs;
    }

    export interface LightService {
        fetch(callback?: (lights: Light[]) => void): Light[];
        get(): Light[];
        find(_id: string): Light;
        create(data: Object, callback?: (res: any) => void);
        control(_id: string, rgb: number[], callback?: (res: any) => void);
    }

    export class Light {
        _id: string;
        name: string;
        lat: number;
        lng: number;
        gid: string;
        marker: googleMaps.Marker;

        http: ng.IHttpService;

        constructor(data?: Object, http?: ng.IHttpService) {
            if (data) {
                var keys = Object.keys(data);
                keys.forEach((k) => {
                    this[k] = data[k];
                });
            }
            
            this.http = http || angular.injector(['ng']).get('$http');
        }

        fetch(callback?: (light: Light) => void): Light {
            this.http.get(config.lightsUrl)
                .success((data: Light) => {
                    var keys = Object.keys(data);
                    keys.forEach((k) => {
                        this[k] = data[k];
                    });

                    if (callback)
                        callback(this);
                })
                .error(() => {
                    console.warn('http get error');
                });

            return this;
        }
    }
}